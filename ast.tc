%option lang = "c++"

%{
    #include "ast.h"

%}

%decls %{
    #include <iostream>
    #include <unordered_map>
    #include <string>
    #include <list>
    #include <string.h>
    #include <cmath>
    #include <vector>

    using std::list;
    using std::cout;
    using std::string;
    using std::vector;

    class Expr;
    using ExprList = vector<Expr*>;

    struct Context {
        std::unordered_map<string, int> vars;
    };
    class Statement;
    using stmtList = list<Statement*>;
%}

%node ASTNode %abstract %typedef

%node Expr ASTNode %abstract

%node Statement ASTNode %abstract

%node BinExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node AddExpr BinExpr
%node SubExpr BinExpr
%node MulExpr BinExpr
%node PowExpr BinExpr
%node DivExpr BinExpr
%node ModExpr BinExpr
%node EquExpr BinExpr
%node NeqExpr BinExpr
%node GrtExpr BinExpr
%node LsrExpr BinExpr
%node GeqExpr BinExpr
%node LeqExpr BinExpr
%node OrExpr  BinExpr
%node AndExpr BinExpr

%node NotExpr Expr = {
    Expr *expr;
}
%node NegExpr Expr = {
    Expr *expr;
}
%node NumExpr Expr = {
    int value;
}
%node IdenExpr Expr = {
    char *var_name;
}

%node StringExpr Expr = {
    string value;
}
%node CharExpr Expr = {
    char value;
}
%node BoolExpr Expr = {
    bool value;
}

%node printStmt Statement = {
    ExprList args;
}
%node assignStmt Statement = {
    char *var_name;
    Expr *expr;
}
%node ifStmt Statement = {
    Expr *expr;
    stmtList true_block;
    stmtList false_block;
}

%operation %virtual string toString(ASTNode *this)
%operation %virtual int eval(Expr *this)
%operation %virtual void exec(Statement *this)

eval(NumExpr) {
    return value;
}

eval(IdenExpr) {
    //return vars[var_name]; cambiar a context
    return 1;
}

eval(AddExpr) {
    return expr1->eval() + expr2->eval();
}

eval(SubExpr) {
    return expr1->eval() - expr2->eval();
}

eval(MulExpr) {
    return expr1->eval() * expr2->eval();
}

eval(PowExpr) {
    return std::pow(expr1->eval(), expr2->eval());
}

eval(DivExpr) {
    return expr1->eval() / expr2->eval();
}

eval(ModExpr) {
    return expr1->eval() % expr2->eval();
}

eval(EquExpr) {
    return expr1->eval() == expr2->eval();
}

eval(NeqExpr) {
    return expr1->eval() != expr2->eval();
}

eval(GrtExpr) {
    return expr1->eval() > expr2->eval();
}

eval(LsrExpr) {
    return expr1->eval() < expr2->eval();
}

eval(GeqExpr) {
    return expr1->eval() >= expr2->eval();
}

eval(LeqExpr) {
    return expr1->eval() <= expr2->eval();
}

eval(OrExpr) {
    return expr1->eval() || expr2->eval();
}

eval(AndExpr) {
    return expr1->eval() && expr2->eval();
}

eval(NotExpr) {
    return !expr->eval();
}

eval(NegExpr) {
    return -expr->eval();
}

eval(StringExpr) {
    return -1;
}

eval(CharExpr) {
    return -1;
}

eval(BoolExpr) {
    return -1;
}

exec(printStmt) {
    for (auto i : args) {
        cout << i->toString();
    }
}

exec(assignStmt) {
    //vars[var_name] = expr->eval();
    ;
}

exec(ifStmt) {
    if (expr->eval()) {
        for (auto i : true_block) {
            i->exec();
        }
    } else {
        for (auto i : false_block) {
            i->exec();
        }
    }
}

%operation %virtual string getString(StringExpr*)
%operation %virtual char getChar(CharExpr*)
%operation %virtual bool getBool(BoolExpr*)
getString(StringExpr) {
    return value;
}
getChar(CharExpr) {
    return value;
}
getBool(BoolExpr) {
    return value;
}

toString(IdenExpr) {
    return var_name;
}

toString(NumExpr) {
    return std::to_string(value);
}

toString(AddExpr) {
    return expr1->toString() + " + " + expr2->toString();
}

toString(SubExpr) {
    return expr1->toString() + " - " + expr2->toString();
}

toString(MulExpr) {
    return expr1->toString() + " * " + expr2->toString();
}

toString(PowExpr) {
    return expr1->toString() + " ^ " + expr2->toString();
}

toString(DivExpr) {
    return expr1->toString() + " div " + expr2->toString();
}

toString(ModExpr) {
    return expr1->toString() + " mod " + expr2->toString();
}

toString(EquExpr) {
    return expr1->toString() + " = " + expr2->toString();
}

toString(NeqExpr) {
    return expr1->toString() + " <> " + expr2->toString();
}

toString(GrtExpr) {
    return expr1->toString() + " > " + expr2->toString();
}

toString(LsrExpr) {
    return expr1->toString() + " < " + expr2->toString();
}

toString(GeqExpr) {
    return expr1->toString() + " >= " + expr2->toString();
}

toString(LeqExpr) {
    return expr1->toString() + " <= " + expr2->toString();
}

toString(OrExpr) {
    return expr1->toString() + " o " + expr2->toString();
}

toString(AndExpr) {
    return expr1->toString() + " y " + expr2->toString();
}

toString(NotExpr) {
    return "no " + expr->toString();
}

toString(NegExpr) {
    return "-" + expr->toString();
}

toString(StringExpr) {
    return value;
}

toString(CharExpr) {
    return "" + value;
}

toString(BoolExpr) {
    return value ? "Verdadero" : "Falso";
}

toString(printStmt) {
    return "Escriba ";// faltan las listas de expresiones
}

toString(assignStmt) {
    //vars[var_name] = expr->toString();
    ;
}

toString(ifStmt) {
    return "si ";
}