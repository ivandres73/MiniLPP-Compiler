%option lang = "c++"

%{
    #include "ast.h"

%}

%decls %{
    #include <iostream>
    #include <unordered_map>
    #include <string>
    #include <list>
    #include <string.h>
    #include <cmath>
    #include <vector>

    using std::list;
    using std::cout;
    using std::string;
    using std::vector;

    class Expr;
    using ExprList = vector<Expr*>;


    struct Context {
        std::unordered_map<string, int> vars;
    };
    class Statement;
    using StmtList = list<Statement*>;
%}

%node ASTNode %abstract %typedef

%node Expr ASTNode %abstract

%node Statement ASTNode %abstract

%node BinExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node AddExpr BinExpr
%node SubExpr BinExpr
%node MulExpr BinExpr
%node PowExpr BinExpr
%node DivExpr BinExpr
%node ModExpr BinExpr
%node EquExpr BinExpr
%node NeqExpr BinExpr
%node GrtExpr BinExpr
%node LsrExpr BinExpr
%node GeqExpr BinExpr
%node LeqExpr BinExpr
%node OrExpr  BinExpr
%node AndExpr BinExpr

%node NotExpr Expr = {
    Expr *expr;
}
%node NegExpr Expr = {
    Expr *expr;
}
%node NumExpr Expr = {
    int value;
}
%node IdenExpr Expr = {
    string var_name;
}
%node BlockExpr Expr = {
    ExprList list;
}

%operation %virtual void addExpr(BlockExpr* this, Expr* e)
addExpr(BlockExpr) {
    list.push_back(e);
}

%node StringExpr Expr = {
    string value;
}
%node CharExpr Expr = {
    char value;
}
%node BoolExpr Expr = {
    bool value;
}

%node BlockStmt Statement = {
    StmtList list;
}

%operation %virtual void addStmt(BlockStmt* this, Statement* s)
addStmt(BlockStmt) {
    list.push_back(s);
}

%node printStmt Statement = {
    BlockExpr *args;
}
%node assignStmt Statement = {
    string var_name;
    Expr *expr;
}
%node ifStmt Statement = {
    Expr *expr;
    StmtList true_block;
    StmtList false_block;
}
%node returnStmt Statement = {
    Expr *expr;
}

%operation %virtual string toString(ASTNode *this)

%operation %virtual string getString(StringExpr*)
%operation %virtual char getChar(CharExpr*)
%operation %virtual bool getBool(BoolExpr*)
getString(StringExpr) {
    return value;
}
getChar(CharExpr) {
    return value;
}
getBool(BoolExpr) {
    return value;
}

toString(IdenExpr) {
    return var_name;
}

toString(NumExpr) {
    return std::to_string(value);
}

toString(AddExpr) {
    return expr1->toString() + " + " + expr2->toString();
}

toString(SubExpr) {
    return expr1->toString() + " - " + expr2->toString();
}

toString(MulExpr) {
    return expr1->toString() + " * " + expr2->toString();
}

toString(PowExpr) {
    return expr1->toString() + " ^ " + expr2->toString();
}

toString(DivExpr) {
    return expr1->toString() + " div " + expr2->toString();
}

toString(ModExpr) {
    return expr1->toString() + " mod " + expr2->toString();
}

toString(EquExpr) {
    return expr1->toString() + " = " + expr2->toString();
}

toString(NeqExpr) {
    return expr1->toString() + " <> " + expr2->toString();
}

toString(GrtExpr) {
    return expr1->toString() + " > " + expr2->toString();
}

toString(LsrExpr) {
    return expr1->toString() + " < " + expr2->toString();
}

toString(GeqExpr) {
    return expr1->toString() + " >= " + expr2->toString();
}

toString(LeqExpr) {
    return expr1->toString() + " <= " + expr2->toString();
}

toString(OrExpr) {
    return expr1->toString() + " o " + expr2->toString();
}

toString(AndExpr) {
    return expr1->toString() + " y " + expr2->toString();
}

toString(NotExpr) {
    return "no " + expr->toString();
}

toString(NegExpr) {
    return "-" + expr->toString();
}

toString(StringExpr) {
    return value;
}

toString(CharExpr) {
    string s = "";
    s += value;
    return s;
}

toString(BoolExpr) {
    return value ? "Verdadero" : "Falso";
}

toString(printStmt) {
    string s("Escriba ");
    s += args->toString();
    return s;
}

toString(assignStmt) {
    return var_name + " <- " + expr->toString();
}

toString(ifStmt) {
    return "si ";
}

toString(returnStmt) {
    string s("retorne");
    if (expr != nullptr) {
        s += " " + expr->toString();
    }
    return s;
}

toString(BlockExpr) {
    string s;
    for (auto i : list) {
        s += i->toString();
    }
    return s;
}

toString(BlockStmt) {
    string s;
    for (auto i : list) {
        s += i->toString();
        s += '\n';
    }
    return s;
}