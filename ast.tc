%option lang = "c++"

%{
    #include "ast.h"

%}

%decls %{
    #include <iostream>
    #include <unordered_map>
    #include <string>
    #include <list>
    #include <string.h>
    #include <cmath>
    #include <vector>

    using std::list;
    using std::cout;
    using std::string;
    using std::vector;

    class Expr;
    using ExprList = vector<Expr*>;

    class ifStmt;
    using ifStmtList = vector<ifStmt*>;

    union val {
        char car;
        bool boo;
        int num;
    };

    struct val_info {
        string scope;//global, gcd, etc etc
        uint8_t type;//0 char, 1 bool, 2 num
        val value;
        uint8_t getType() { return type; }
    };

    struct Context {
        std::unordered_map<string, val_info> vars;
    };

    class Statement;
    using StmtList = list<Statement*>;
%}

%node ASTNode %abstract %typedef

%node Expr ASTNode %abstract

%node Statement ASTNode %abstract

%node BinExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node AddExpr BinExpr
%node SubExpr BinExpr
%node MulExpr BinExpr
%node PowExpr BinExpr
%node DivExpr BinExpr
%node ModExpr BinExpr
%node EquExpr BinExpr
%node NeqExpr BinExpr
%node GrtExpr BinExpr
%node LsrExpr BinExpr
%node GeqExpr BinExpr
%node LeqExpr BinExpr
%node OrExpr  BinExpr
%node AndExpr BinExpr

%node NotExpr Expr = {
    Expr *expr;
}
%node NegExpr Expr = {
    Expr *expr;
}
%node NumExpr Expr = {
    int value;
}
%node IdenExpr Expr = {
    string var_name;
}
%node BlockExpr Expr = {
    ExprList list;
}

%operation %virtual void addExpr(BlockExpr* this, Expr* e)
%operation %virtual void copyFrom(BlockExpr* this, BlockExpr* src)
addExpr(BlockExpr) {
    list.push_back(e);
}
copyFrom(BlockExpr) {
    Context empty;
    for (auto i : src->list) {
        list.push_back(i);
        //cout << i->toString(empty) << '\n';
    }
}

%node StringExpr Expr = {
    string value;
}
%node CharExpr Expr = {
    char value;
}
%node BoolExpr Expr = {
    bool value;
}

%node BlockStmt Statement = {
    StmtList list;
}

%operation %virtual void addStmt(BlockStmt* this, Statement* s)
addStmt(BlockStmt) {
    list.push_back(s);
}

%node printStmt Statement = {
    BlockExpr *args;
}
%node assignStmt Statement = {
    string var_name;
    Expr *expr;
}
%node ifStmt Statement = {
    Expr *expr;
    BlockStmt *true_block;
    elseifBlock *elses;
}
%node elseifBlock Statement = {
    ifStmtList elseifs;
    BlockStmt *false_block;
}
%operation %virtual void addIfStmt(elseifBlock* this, ifStmt* is)
addIfStmt(elseifBlock) {
    elseifs.push_back(is);
}

%node returnStmt Statement = {
    Expr *expr;
}
%node readStmt Statement = {
    string lval;
}
%node callStmt Statement = {
    string id;
}
%node whileStmt Statement = {
    Expr *expr;
    BlockStmt *block;
}
%node doStmt Statement = {
    BlockStmt *b;
    Expr *expr;
}
%node forStmt Statement = {
    string id;
    Expr *init_expr;
    Expr *fin_expr;
    BlockStmt *block;
}
%node declStmt Statement = {
    string type;
    BlockExpr *ids;
}

%operation %virtual string toString(ASTNode *this, Context &ctx)

%operation %virtual string getString(StringExpr*)
%operation %virtual char getChar(CharExpr*)
%operation %virtual bool getBool(BoolExpr*)
getString(StringExpr) { return value; }
getChar(CharExpr) { return value; }
getBool(BoolExpr) { return value; }
toString(IdenExpr) { return var_name; }
toString(NumExpr) { return std::to_string(value); }

toString(AddExpr) {
    return expr1->toString(ctx) + " + " + expr2->toString(ctx);
}

toString(SubExpr) {
    return expr1->toString(ctx) + " - " + expr2->toString(ctx);
}

toString(MulExpr) {
    return expr1->toString(ctx) + " * " + expr2->toString(ctx);
}

toString(PowExpr) {
    return expr1->toString(ctx) + " ^ " + expr2->toString(ctx);
}

toString(DivExpr) {
    return expr1->toString(ctx) + " div " + expr2->toString(ctx);
}

toString(ModExpr) {
    return expr1->toString(ctx) + " mod " + expr2->toString(ctx);
}

toString(EquExpr) {
    return expr1->toString(ctx) + " = " + expr2->toString(ctx);
}

toString(NeqExpr) {
    return expr1->toString(ctx) + " <> " + expr2->toString(ctx);
}

toString(GrtExpr) {
    return expr1->toString(ctx) + " > " + expr2->toString(ctx);
}

toString(LsrExpr) {
    return expr1->toString(ctx) + " < " + expr2->toString(ctx);
}

toString(GeqExpr) {
    return expr1->toString(ctx) + " >= " + expr2->toString(ctx);
}

toString(LeqExpr) {
    return expr1->toString(ctx) + " <= " + expr2->toString(ctx);
}

toString(OrExpr) {
    return expr1->toString(ctx) + " o " + expr2->toString(ctx);
}

toString(AndExpr) {
    return expr1->toString(ctx) + " y " + expr2->toString(ctx);
}

toString(NotExpr) {
    return "no " + expr->toString(ctx);
}

toString(NegExpr) {
    return "-" + expr->toString(ctx);
}

toString(StringExpr) { return value; }

toString(CharExpr) {
    string s = "";
    s += value;
    return s;
}

toString(BoolExpr) { return value ? "Verdadero" : "Falso"; }

toString(printStmt) {
    string s("Escriba ");
    s += args->toString(ctx);
    return s;
}

toString(assignStmt) {
    return var_name + " <- " + expr->toString(ctx);
}

toString(ifStmt) {
    string s("si ");
    s += expr->toString(ctx);
    s += " entonces\n";
    s += true_block->toString(ctx);
    if (elses != nullptr) {
        if (elses->elseifs.empty()) {
            s += "\nsino\n";
            s += elses->false_block->toString(ctx);
        }
    }
    s += "fin si";
    return s;
}

toString(elseifBlock) {
    return "soy elses";
}

toString(returnStmt) {
    string s("retorne");
    if (expr != nullptr) {
        s += " " + expr->toString(ctx);
    }
    return s;
}

toString(BlockExpr) {
    string s;
    for (auto i : list) {
        s += i->toString(ctx);
    }
    return s;
}

toString(BlockStmt) {
    string s;
    for (auto i : list) {
        s += i->toString(ctx);
        s += '\n';
    }
    return s;
}

toString(readStmt) {
    string s("lea ");
    s += lval;
    return s;
}

toString(callStmt) {
    string s("llamar ");
    s += id;
    return s;
}

toString(whileStmt) {
    string s("mientras ");
    s += expr->toString(ctx);
    s += " haga\n";
    s += block->toString(ctx);
    s += "\nfin mientras";
    return s;
}

toString(doStmt) {
    string s("repita\n");
    s += b->toString(ctx);
    s += "hasta " + expr->toString(ctx);
    return s;
}

toString(forStmt) {
    string s("para ");
    s += id;
    s += " <- ";
    s += init_expr->toString(ctx);
    s += " hasta ";
    s += fin_expr->toString(ctx);
    s += " haga\n";
    s += block->toString(ctx);
    s += "\nfin para";
    return s;
}
    // union val {
    //     char car;
    //     bool boo;
    //     int num;
    // };

    // struct val_info {
    //     string scope;//global, gcd, etc etc
    //     uint8_t type;//0 char, 1 bool, 2 num
    //     val value;
    //     uint8_t getType() { return type; }
    // };
toString(declStmt) {
    string s(type);
    s += " " + ids->toString(ctx);
    for (auto i : ids->list) {
        //if (ctx.vars.find(((StringExpr*)i)->value) == ctx.vars.end()) {
            cout << "escribo var " << i->toString(ctx) << '\n';
            //vars.emplace();
        //}
    }
    return s;
}